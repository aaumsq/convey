//
// Generated by Bluespec Compiler, version 2014.07.A (build 34078, 2014-07-30)
//
// On Thu Mar  8 22:02:38 CST 2018
//
//
// Ports:
// Name                         I/O  size props
// RDY_req_put                    O     1
// resp_get                       O   138
// RDY_resp_get                   O     1 reg
// memReq_get                     O   122
// RDY_memReq_get                 O     1 reg
// RDY_memResp_put                O     1 reg
// RDY_init                       O     1 const
// CLK                            I     1 clock
// RST_N                          I     1 reset
// req_put                        I   106
// memResp_put                    I    71 reg
// init_fpgaId                    I     2 reg
// init_laneId                    I     4 reg
// init_nodePtr                   I    48 reg
// init_edgePtr                   I    48 reg
// EN_req_put                     I     1
// EN_memResp_put                 I     1
// EN_init                        I     1
// EN_resp_get                    I     1
// EN_memReq_get                  I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkGraphLanePipe(CLK,
		       RST_N,

		       req_put,
		       EN_req_put,
		       RDY_req_put,

		       EN_resp_get,
		       resp_get,
		       RDY_resp_get,

		       EN_memReq_get,
		       memReq_get,
		       RDY_memReq_get,

		       memResp_put,
		       EN_memResp_put,
		       RDY_memResp_put,

		       init_fpgaId,
		       init_laneId,
		       init_nodePtr,
		       init_edgePtr,
		       EN_init,
		       RDY_init);
  input  CLK;
  input  RST_N;

  // action method req_put
  input  [105 : 0] req_put;
  input  EN_req_put;
  output RDY_req_put;

  // actionvalue method resp_get
  input  EN_resp_get;
  output [137 : 0] resp_get;
  output RDY_resp_get;

  // actionvalue method memReq_get
  input  EN_memReq_get;
  output [121 : 0] memReq_get;
  output RDY_memReq_get;

  // action method memResp_put
  input  [70 : 0] memResp_put;
  input  EN_memResp_put;
  output RDY_memResp_put;

  // action method init
  input  [1 : 0] init_fpgaId;
  input  [3 : 0] init_laneId;
  input  [47 : 0] init_nodePtr;
  input  [47 : 0] init_edgePtr;
  input  EN_init;
  output RDY_init;

  // signals for module outputs
  wire [137 : 0] resp_get;
  wire [121 : 0] memReq_get;
  wire RDY_init, RDY_memReq_get, RDY_memResp_put, RDY_req_put, RDY_resp_get;

  // register edgePtr
  reg [47 : 0] edgePtr;
  wire [47 : 0] edgePtr$D_IN;
  wire edgePtr$EN;

  // register fpgaId
  reg [1 : 0] fpgaId;
  wire [1 : 0] fpgaId$D_IN;
  wire fpgaId$EN;

  // register laneId
  reg [3 : 0] laneId;
  wire [3 : 0] laneId$D_IN;
  wire laneId$EN;

  // register nodePtr
  reg [47 : 0] nodePtr;
  wire [47 : 0] nodePtr$D_IN;
  wire nodePtr$EN;

  // register started
  reg started;
  wire started$D_IN, started$EN;

  // ports of submodule casQ
  wire [103 : 0] casQ$D_IN, casQ$D_OUT;
  wire casQ$CLR, casQ$DEQ, casQ$EMPTY_N, casQ$ENQ, casQ$FULL_N;

  // ports of submodule casQ2
  wire [103 : 0] casQ2$D_IN, casQ2$D_OUT;
  wire casQ2$CLR, casQ2$DEQ, casQ2$EMPTY_N, casQ2$ENQ, casQ2$FULL_N;

  // ports of submodule memReqQ
  reg [121 : 0] memReqQ$D_IN;
  wire [121 : 0] memReqQ$D_OUT;
  wire memReqQ$CLR, memReqQ$DEQ, memReqQ$EMPTY_N, memReqQ$ENQ, memReqQ$FULL_N;

  // ports of submodule memRespQ
  wire [70 : 0] memRespQ$D_IN, memRespQ$D_OUT;
  wire memRespQ$CLR,
       memRespQ$DEQ,
       memRespQ$EMPTY_N,
       memRespQ$ENQ,
       memRespQ$FULL_N;

  // ports of submodule memRespQs_0
  wire [70 : 0] memRespQs_0$D_IN, memRespQs_0$D_OUT;
  wire memRespQs_0$CLR,
       memRespQs_0$DEQ,
       memRespQs_0$EMPTY_N,
       memRespQs_0$ENQ,
       memRespQs_0$FULL_N;

  // ports of submodule memRespQs_1
  wire [70 : 0] memRespQs_1$D_IN, memRespQs_1$D_OUT;
  wire memRespQs_1$CLR,
       memRespQs_1$DEQ,
       memRespQs_1$EMPTY_N,
       memRespQs_1$ENQ,
       memRespQs_1$FULL_N;

  // ports of submodule memRespQs_2
  wire [70 : 0] memRespQs_2$D_IN, memRespQs_2$D_OUT;
  wire memRespQs_2$CLR,
       memRespQs_2$DEQ,
       memRespQs_2$EMPTY_N,
       memRespQs_2$ENQ,
       memRespQs_2$FULL_N;

  // ports of submodule memRespQs_3
  wire [70 : 0] memRespQs_3$D_IN, memRespQs_3$D_OUT;
  wire memRespQs_3$CLR,
       memRespQs_3$DEQ,
       memRespQs_3$EMPTY_N,
       memRespQs_3$ENQ,
       memRespQs_3$FULL_N;

  // ports of submodule readEdgeQ
  wire [39 : 0] readEdgeQ$D_IN, readEdgeQ$D_OUT;
  wire readEdgeQ$CLR,
       readEdgeQ$DEQ,
       readEdgeQ$EMPTY_N,
       readEdgeQ$ENQ,
       readEdgeQ$FULL_N;

  // ports of submodule readEdgeQ2
  wire [39 : 0] readEdgeQ2$D_IN, readEdgeQ2$D_OUT;
  wire readEdgeQ2$CLR,
       readEdgeQ2$DEQ,
       readEdgeQ2$EMPTY_N,
       readEdgeQ2$ENQ,
       readEdgeQ2$FULL_N;

  // ports of submodule readNodeQ
  wire [39 : 0] readNodeQ$D_IN, readNodeQ$D_OUT;
  wire readNodeQ$CLR,
       readNodeQ$DEQ,
       readNodeQ$EMPTY_N,
       readNodeQ$ENQ,
       readNodeQ$FULL_N;

  // ports of submodule readNodeQ2
  wire [39 : 0] readNodeQ2$D_IN, readNodeQ2$D_OUT;
  wire readNodeQ2$CLR,
       readNodeQ2$DEQ,
       readNodeQ2$EMPTY_N,
       readNodeQ2$ENQ,
       readNodeQ2$FULL_N;

  // ports of submodule readNodeQ3
  wire [39 : 0] readNodeQ3$D_IN, readNodeQ3$D_OUT;
  wire readNodeQ3$CLR,
       readNodeQ3$DEQ,
       readNodeQ3$EMPTY_N,
       readNodeQ3$ENQ,
       readNodeQ3$FULL_N;

  // ports of submodule readNodeQ3_partialNode
  wire [63 : 0] readNodeQ3_partialNode$D_IN, readNodeQ3_partialNode$D_OUT;
  wire readNodeQ3_partialNode$CLR,
       readNodeQ3_partialNode$DEQ,
       readNodeQ3_partialNode$EMPTY_N,
       readNodeQ3_partialNode$ENQ,
       readNodeQ3_partialNode$FULL_N;

  // ports of submodule respQ
  reg [137 : 0] respQ$D_IN;
  wire [137 : 0] respQ$D_OUT;
  wire respQ$CLR, respQ$DEQ, respQ$EMPTY_N, respQ$ENQ, respQ$FULL_N;

  // rule scheduling signals
  wire CAN_FIRE_RL_readNode2,
       WILL_FIRE_RL_cas,
       WILL_FIRE_RL_cas2,
       WILL_FIRE_RL_memResp_distribute,
       WILL_FIRE_RL_readEdge,
       WILL_FIRE_RL_readEdge2,
       WILL_FIRE_RL_readNode,
       WILL_FIRE_RL_readNode2,
       WILL_FIRE_RL_readNode3;

  // inputs to muxes for submodule ports
  wire [137 : 0] MUX_respQ$enq_1__VAL_1,
		 MUX_respQ$enq_1__VAL_2,
		 MUX_respQ$enq_1__VAL_3;
  wire [121 : 0] MUX_memReqQ$enq_1__VAL_1,
		 MUX_memReqQ$enq_1__VAL_2,
		 MUX_memReqQ$enq_1__VAL_3,
		 MUX_memReqQ$enq_1__VAL_4;

  // remaining internal signals
  reg [31 : 0] v__h4354, v__h4360;
  reg [2 : 0] CASE_memReqQD_OUT_BITS_121_TO_119_0_memReqQD_ETC__q1;
  reg [1 : 0] CASE_respQD_OUT_BITS_137_TO_136_0_respQD_OUT_ETC__q2;
  reg CASE_memRespQ_first_BITS_68_TO_64_0_memRespQs__ETC___d8;
  wire [47 : 0] vaddrBase__h1738,
		vaddr__h1739,
		vaddr__h2349,
		vaddr__h3055,
		vaddr__h3299,
		x__h3329,
		y__h3332;

  // action method req_put
  assign RDY_req_put = readNodeQ$FULL_N && readEdgeQ$FULL_N && casQ$FULL_N ;

  // actionvalue method resp_get
  assign resp_get =
	     { CASE_respQD_OUT_BITS_137_TO_136_0_respQD_OUT_ETC__q2,
	       respQ$D_OUT[135:0] } ;
  assign RDY_resp_get = respQ$EMPTY_N ;

  // actionvalue method memReq_get
  assign memReq_get =
	     { CASE_memReqQD_OUT_BITS_121_TO_119_0_memReqQD_ETC__q1,
	       memReqQ$D_OUT[118:0] } ;
  assign RDY_memReq_get = memReqQ$EMPTY_N ;

  // action method memResp_put
  assign RDY_memResp_put = memRespQ$FULL_N ;

  // action method init
  assign RDY_init = 1'd1 ;

  // submodule casQ
  FIFO2 #(.width(32'd104), .guarded(32'd1)) casQ(.RST(RST_N),
						 .CLK(CLK),
						 .D_IN(casQ$D_IN),
						 .ENQ(casQ$ENQ),
						 .DEQ(casQ$DEQ),
						 .CLR(casQ$CLR),
						 .D_OUT(casQ$D_OUT),
						 .FULL_N(casQ$FULL_N),
						 .EMPTY_N(casQ$EMPTY_N));

  // submodule casQ2
  SizedFIFO #(.p1width(32'd104),
	      .p2depth(32'd256),
	      .p3cntr_width(32'd8),
	      .guarded(32'd1)) casQ2(.RST(RST_N),
				     .CLK(CLK),
				     .D_IN(casQ2$D_IN),
				     .ENQ(casQ2$ENQ),
				     .DEQ(casQ2$DEQ),
				     .CLR(casQ2$CLR),
				     .D_OUT(casQ2$D_OUT),
				     .FULL_N(casQ2$FULL_N),
				     .EMPTY_N(casQ2$EMPTY_N));

  // submodule memReqQ
  FIFO2 #(.width(32'd122), .guarded(32'd1)) memReqQ(.RST(RST_N),
						    .CLK(CLK),
						    .D_IN(memReqQ$D_IN),
						    .ENQ(memReqQ$ENQ),
						    .DEQ(memReqQ$DEQ),
						    .CLR(memReqQ$CLR),
						    .D_OUT(memReqQ$D_OUT),
						    .FULL_N(memReqQ$FULL_N),
						    .EMPTY_N(memReqQ$EMPTY_N));

  // submodule memRespQ
  FIFO2 #(.width(32'd71), .guarded(32'd1)) memRespQ(.RST(RST_N),
						    .CLK(CLK),
						    .D_IN(memRespQ$D_IN),
						    .ENQ(memRespQ$ENQ),
						    .DEQ(memRespQ$DEQ),
						    .CLR(memRespQ$CLR),
						    .D_OUT(memRespQ$D_OUT),
						    .FULL_N(memRespQ$FULL_N),
						    .EMPTY_N(memRespQ$EMPTY_N));

  // submodule memRespQs_0
  FIFO2 #(.width(32'd71), .guarded(32'd1)) memRespQs_0(.RST(RST_N),
						       .CLK(CLK),
						       .D_IN(memRespQs_0$D_IN),
						       .ENQ(memRespQs_0$ENQ),
						       .DEQ(memRespQs_0$DEQ),
						       .CLR(memRespQs_0$CLR),
						       .D_OUT(memRespQs_0$D_OUT),
						       .FULL_N(memRespQs_0$FULL_N),
						       .EMPTY_N(memRespQs_0$EMPTY_N));

  // submodule memRespQs_1
  FIFO2 #(.width(32'd71), .guarded(32'd1)) memRespQs_1(.RST(RST_N),
						       .CLK(CLK),
						       .D_IN(memRespQs_1$D_IN),
						       .ENQ(memRespQs_1$ENQ),
						       .DEQ(memRespQs_1$DEQ),
						       .CLR(memRespQs_1$CLR),
						       .D_OUT(memRespQs_1$D_OUT),
						       .FULL_N(memRespQs_1$FULL_N),
						       .EMPTY_N(memRespQs_1$EMPTY_N));

  // submodule memRespQs_2
  FIFO2 #(.width(32'd71), .guarded(32'd1)) memRespQs_2(.RST(RST_N),
						       .CLK(CLK),
						       .D_IN(memRespQs_2$D_IN),
						       .ENQ(memRespQs_2$ENQ),
						       .DEQ(memRespQs_2$DEQ),
						       .CLR(memRespQs_2$CLR),
						       .D_OUT(memRespQs_2$D_OUT),
						       .FULL_N(memRespQs_2$FULL_N),
						       .EMPTY_N(memRespQs_2$EMPTY_N));

  // submodule memRespQs_3
  FIFO2 #(.width(32'd71), .guarded(32'd1)) memRespQs_3(.RST(RST_N),
						       .CLK(CLK),
						       .D_IN(memRespQs_3$D_IN),
						       .ENQ(memRespQs_3$ENQ),
						       .DEQ(memRespQs_3$DEQ),
						       .CLR(memRespQs_3$CLR),
						       .D_OUT(memRespQs_3$D_OUT),
						       .FULL_N(memRespQs_3$FULL_N),
						       .EMPTY_N(memRespQs_3$EMPTY_N));

  // submodule readEdgeQ
  FIFO2 #(.width(32'd40), .guarded(32'd1)) readEdgeQ(.RST(RST_N),
						     .CLK(CLK),
						     .D_IN(readEdgeQ$D_IN),
						     .ENQ(readEdgeQ$ENQ),
						     .DEQ(readEdgeQ$DEQ),
						     .CLR(readEdgeQ$CLR),
						     .D_OUT(readEdgeQ$D_OUT),
						     .FULL_N(readEdgeQ$FULL_N),
						     .EMPTY_N(readEdgeQ$EMPTY_N));

  // submodule readEdgeQ2
  SizedFIFO #(.p1width(32'd40),
	      .p2depth(32'd256),
	      .p3cntr_width(32'd8),
	      .guarded(32'd1)) readEdgeQ2(.RST(RST_N),
					  .CLK(CLK),
					  .D_IN(readEdgeQ2$D_IN),
					  .ENQ(readEdgeQ2$ENQ),
					  .DEQ(readEdgeQ2$DEQ),
					  .CLR(readEdgeQ2$CLR),
					  .D_OUT(readEdgeQ2$D_OUT),
					  .FULL_N(readEdgeQ2$FULL_N),
					  .EMPTY_N(readEdgeQ2$EMPTY_N));

  // submodule readNodeQ
  FIFO2 #(.width(32'd40), .guarded(32'd1)) readNodeQ(.RST(RST_N),
						     .CLK(CLK),
						     .D_IN(readNodeQ$D_IN),
						     .ENQ(readNodeQ$ENQ),
						     .DEQ(readNodeQ$DEQ),
						     .CLR(readNodeQ$CLR),
						     .D_OUT(readNodeQ$D_OUT),
						     .FULL_N(readNodeQ$FULL_N),
						     .EMPTY_N(readNodeQ$EMPTY_N));

  // submodule readNodeQ2
  SizedFIFO #(.p1width(32'd40),
	      .p2depth(32'd256),
	      .p3cntr_width(32'd8),
	      .guarded(32'd1)) readNodeQ2(.RST(RST_N),
					  .CLK(CLK),
					  .D_IN(readNodeQ2$D_IN),
					  .ENQ(readNodeQ2$ENQ),
					  .DEQ(readNodeQ2$DEQ),
					  .CLR(readNodeQ2$CLR),
					  .D_OUT(readNodeQ2$D_OUT),
					  .FULL_N(readNodeQ2$FULL_N),
					  .EMPTY_N(readNodeQ2$EMPTY_N));

  // submodule readNodeQ3
  SizedFIFO #(.p1width(32'd40),
	      .p2depth(32'd256),
	      .p3cntr_width(32'd8),
	      .guarded(32'd1)) readNodeQ3(.RST(RST_N),
					  .CLK(CLK),
					  .D_IN(readNodeQ3$D_IN),
					  .ENQ(readNodeQ3$ENQ),
					  .DEQ(readNodeQ3$DEQ),
					  .CLR(readNodeQ3$CLR),
					  .D_OUT(readNodeQ3$D_OUT),
					  .FULL_N(readNodeQ3$FULL_N),
					  .EMPTY_N(readNodeQ3$EMPTY_N));

  // submodule readNodeQ3_partialNode
  SizedFIFO #(.p1width(32'd64),
	      .p2depth(32'd256),
	      .p3cntr_width(32'd8),
	      .guarded(32'd1)) readNodeQ3_partialNode(.RST(RST_N),
						      .CLK(CLK),
						      .D_IN(readNodeQ3_partialNode$D_IN),
						      .ENQ(readNodeQ3_partialNode$ENQ),
						      .DEQ(readNodeQ3_partialNode$DEQ),
						      .CLR(readNodeQ3_partialNode$CLR),
						      .D_OUT(readNodeQ3_partialNode$D_OUT),
						      .FULL_N(readNodeQ3_partialNode$FULL_N),
						      .EMPTY_N(readNodeQ3_partialNode$EMPTY_N));

  // submodule respQ
  FIFO2 #(.width(32'd138), .guarded(32'd1)) respQ(.RST(RST_N),
						  .CLK(CLK),
						  .D_IN(respQ$D_IN),
						  .ENQ(respQ$ENQ),
						  .DEQ(respQ$DEQ),
						  .CLR(respQ$CLR),
						  .D_OUT(respQ$D_OUT),
						  .FULL_N(respQ$FULL_N),
						  .EMPTY_N(respQ$EMPTY_N));

  // rule RL_memResp_distribute
  assign WILL_FIRE_RL_memResp_distribute =
	     memRespQ$EMPTY_N &&
	     CASE_memRespQ_first_BITS_68_TO_64_0_memRespQs__ETC___d8 ;

  // rule RL_cas
  assign WILL_FIRE_RL_cas = casQ$EMPTY_N && casQ2$FULL_N && memReqQ$FULL_N ;

  // rule RL_cas2
  assign WILL_FIRE_RL_cas2 =
	     casQ2$EMPTY_N && memRespQs_0$EMPTY_N && respQ$FULL_N ;

  // rule RL_readEdge
  assign WILL_FIRE_RL_readEdge =
	     memReqQ$FULL_N && readEdgeQ$EMPTY_N && readEdgeQ2$FULL_N &&
	     !WILL_FIRE_RL_cas ;

  // rule RL_readEdge2
  assign WILL_FIRE_RL_readEdge2 =
	     respQ$FULL_N && readEdgeQ2$EMPTY_N && memRespQs_1$EMPTY_N &&
	     !WILL_FIRE_RL_cas2 ;

  // rule RL_readNode
  assign WILL_FIRE_RL_readNode =
	     memReqQ$FULL_N && readNodeQ$EMPTY_N && readNodeQ2$FULL_N &&
	     !WILL_FIRE_RL_readNode2 &&
	     !WILL_FIRE_RL_readEdge &&
	     !WILL_FIRE_RL_cas ;

  // rule RL_readNode2
  assign CAN_FIRE_RL_readNode2 =
	     memReqQ$FULL_N && readNodeQ2$EMPTY_N && readNodeQ3$FULL_N &&
	     memRespQs_2$EMPTY_N &&
	     readNodeQ3_partialNode$FULL_N ;
  assign WILL_FIRE_RL_readNode2 =
	     CAN_FIRE_RL_readNode2 && !WILL_FIRE_RL_readEdge &&
	     !WILL_FIRE_RL_cas ;

  // rule RL_readNode3
  assign WILL_FIRE_RL_readNode3 =
	     respQ$FULL_N && readNodeQ3$EMPTY_N &&
	     readNodeQ3_partialNode$EMPTY_N &&
	     memRespQs_3$EMPTY_N &&
	     !WILL_FIRE_RL_readEdge2 &&
	     !WILL_FIRE_RL_cas2 ;

  // inputs to muxes for submodule ports
  assign MUX_memReqQ$enq_1__VAL_1 =
	     { 3'd4, vaddr__h1739, 7'd64, casQ$D_OUT[71:8] } ;
  assign MUX_memReqQ$enq_1__VAL_2 =
	     { 67'h0AAAAAAAAAAAAAAAA, vaddr__h2349, 7'd65 } ;
  assign MUX_memReqQ$enq_1__VAL_3 =
	     { 67'h0AAAAAAAAAAAAAAAA, vaddr__h3055, 7'd66 } ;
  assign MUX_memReqQ$enq_1__VAL_4 =
	     { 67'h0AAAAAAAAAAAAAAAA, vaddr__h3299, 7'd67 } ;
  assign MUX_respQ$enq_1__VAL_1 =
	     { 97'h12AAAAAAAAAAAAAAAAAAAAAAA,
	       memRespQs_0$D_OUT[31:0] == casQ2$D_OUT[71:40],
	       memRespQs_0$D_OUT[31:0],
	       casQ2$D_OUT[7:0] } ;
  assign MUX_respQ$enq_1__VAL_2 =
	     { 66'h1AAAAAAAAAAAAAAAA,
	       memRespQs_1$D_OUT[63:0],
	       readEdgeQ2$D_OUT[7:0] } ;
  assign MUX_respQ$enq_1__VAL_3 =
	     { 2'd0,
	       memRespQs_3$D_OUT[63:0],
	       readNodeQ3_partialNode$D_OUT,
	       readNodeQ3$D_OUT[7:0] } ;

  // register edgePtr
  assign edgePtr$D_IN = init_edgePtr ;
  assign edgePtr$EN = EN_init ;

  // register fpgaId
  assign fpgaId$D_IN = init_fpgaId ;
  assign fpgaId$EN = EN_init ;

  // register laneId
  assign laneId$D_IN = init_laneId ;
  assign laneId$EN = EN_init ;

  // register nodePtr
  assign nodePtr$D_IN = init_nodePtr ;
  assign nodePtr$EN = EN_init ;

  // register started
  assign started$D_IN = 1'd1 ;
  assign started$EN = EN_init ;

  // submodule casQ
  assign casQ$D_IN = req_put[103:0] ;
  assign casQ$ENQ =
	     EN_req_put && req_put[105:104] != 2'd0 &&
	     req_put[105:104] != 2'd1 ;
  assign casQ$DEQ = WILL_FIRE_RL_cas ;
  assign casQ$CLR = 1'b0 ;

  // submodule casQ2
  assign casQ2$D_IN = casQ$D_OUT ;
  assign casQ2$ENQ = WILL_FIRE_RL_cas ;
  assign casQ2$DEQ = WILL_FIRE_RL_cas2 ;
  assign casQ2$CLR = 1'b0 ;

  // submodule memReqQ
  always@(WILL_FIRE_RL_cas or
	  MUX_memReqQ$enq_1__VAL_1 or
	  WILL_FIRE_RL_readEdge or
	  MUX_memReqQ$enq_1__VAL_2 or
	  WILL_FIRE_RL_readNode or
	  MUX_memReqQ$enq_1__VAL_3 or
	  WILL_FIRE_RL_readNode2 or MUX_memReqQ$enq_1__VAL_4)
  begin
    case (1'b1) // synopsys parallel_case
      WILL_FIRE_RL_cas: memReqQ$D_IN = MUX_memReqQ$enq_1__VAL_1;
      WILL_FIRE_RL_readEdge: memReqQ$D_IN = MUX_memReqQ$enq_1__VAL_2;
      WILL_FIRE_RL_readNode: memReqQ$D_IN = MUX_memReqQ$enq_1__VAL_3;
      WILL_FIRE_RL_readNode2: memReqQ$D_IN = MUX_memReqQ$enq_1__VAL_4;
      default: memReqQ$D_IN =
		   122'h2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAA /* unspecified value */ ;
    endcase
  end
  assign memReqQ$ENQ =
	     WILL_FIRE_RL_cas || WILL_FIRE_RL_readEdge ||
	     WILL_FIRE_RL_readNode ||
	     WILL_FIRE_RL_readNode2 ;
  assign memReqQ$DEQ = EN_memReq_get ;
  assign memReqQ$CLR = 1'b0 ;

  // submodule memRespQ
  assign memRespQ$D_IN = memResp_put ;
  assign memRespQ$ENQ = EN_memResp_put ;
  assign memRespQ$DEQ = WILL_FIRE_RL_memResp_distribute ;
  assign memRespQ$CLR = 1'b0 ;

  // submodule memRespQs_0
  assign memRespQs_0$D_IN = memRespQ$D_OUT ;
  assign memRespQs_0$ENQ =
	     WILL_FIRE_RL_memResp_distribute &&
	     memRespQ$D_OUT[68:64] == 5'd0 ;
  assign memRespQs_0$DEQ = WILL_FIRE_RL_cas2 ;
  assign memRespQs_0$CLR = 1'b0 ;

  // submodule memRespQs_1
  assign memRespQs_1$D_IN = memRespQ$D_OUT ;
  assign memRespQs_1$ENQ =
	     WILL_FIRE_RL_memResp_distribute &&
	     memRespQ$D_OUT[68:64] == 5'd1 ;
  assign memRespQs_1$DEQ = WILL_FIRE_RL_readEdge2 ;
  assign memRespQs_1$CLR = 1'b0 ;

  // submodule memRespQs_2
  assign memRespQs_2$D_IN = memRespQ$D_OUT ;
  assign memRespQs_2$ENQ =
	     WILL_FIRE_RL_memResp_distribute &&
	     memRespQ$D_OUT[68:64] == 5'd2 ;
  assign memRespQs_2$DEQ = WILL_FIRE_RL_readNode2 ;
  assign memRespQs_2$CLR = 1'b0 ;

  // submodule memRespQs_3
  assign memRespQs_3$D_IN = memRespQ$D_OUT ;
  assign memRespQs_3$ENQ =
	     WILL_FIRE_RL_memResp_distribute &&
	     memRespQ$D_OUT[68:64] == 5'd3 ;
  assign memRespQs_3$DEQ = WILL_FIRE_RL_readNode3 ;
  assign memRespQs_3$CLR = 1'b0 ;

  // submodule readEdgeQ
  assign readEdgeQ$D_IN = req_put[39:0] ;
  assign readEdgeQ$ENQ = EN_req_put && req_put[105:104] == 2'd1 ;
  assign readEdgeQ$DEQ = WILL_FIRE_RL_readEdge ;
  assign readEdgeQ$CLR = 1'b0 ;

  // submodule readEdgeQ2
  assign readEdgeQ2$D_IN = readEdgeQ$D_OUT ;
  assign readEdgeQ2$ENQ = WILL_FIRE_RL_readEdge ;
  assign readEdgeQ2$DEQ = WILL_FIRE_RL_readEdge2 ;
  assign readEdgeQ2$CLR = 1'b0 ;

  // submodule readNodeQ
  assign readNodeQ$D_IN = req_put[39:0] ;
  assign readNodeQ$ENQ = EN_req_put && req_put[105:104] == 2'd0 ;
  assign readNodeQ$DEQ = WILL_FIRE_RL_readNode ;
  assign readNodeQ$CLR = 1'b0 ;

  // submodule readNodeQ2
  assign readNodeQ2$D_IN = readNodeQ$D_OUT ;
  assign readNodeQ2$ENQ = WILL_FIRE_RL_readNode ;
  assign readNodeQ2$DEQ = WILL_FIRE_RL_readNode2 ;
  assign readNodeQ2$CLR = 1'b0 ;

  // submodule readNodeQ3
  assign readNodeQ3$D_IN = readNodeQ2$D_OUT ;
  assign readNodeQ3$ENQ = WILL_FIRE_RL_readNode2 ;
  assign readNodeQ3$DEQ = WILL_FIRE_RL_readNode3 ;
  assign readNodeQ3$CLR = 1'b0 ;

  // submodule readNodeQ3_partialNode
  assign readNodeQ3_partialNode$D_IN = memRespQs_2$D_OUT[63:0] ;
  assign readNodeQ3_partialNode$ENQ = WILL_FIRE_RL_readNode2 ;
  assign readNodeQ3_partialNode$DEQ = WILL_FIRE_RL_readNode3 ;
  assign readNodeQ3_partialNode$CLR = 1'b0 ;

  // submodule respQ
  always@(WILL_FIRE_RL_cas2 or
	  MUX_respQ$enq_1__VAL_1 or
	  WILL_FIRE_RL_readEdge2 or
	  MUX_respQ$enq_1__VAL_2 or
	  WILL_FIRE_RL_readNode3 or MUX_respQ$enq_1__VAL_3)
  begin
    case (1'b1) // synopsys parallel_case
      WILL_FIRE_RL_cas2: respQ$D_IN = MUX_respQ$enq_1__VAL_1;
      WILL_FIRE_RL_readEdge2: respQ$D_IN = MUX_respQ$enq_1__VAL_2;
      WILL_FIRE_RL_readNode3: respQ$D_IN = MUX_respQ$enq_1__VAL_3;
      default: respQ$D_IN =
		   138'h2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA /* unspecified value */ ;
    endcase
  end
  assign respQ$ENQ =
	     WILL_FIRE_RL_cas2 || WILL_FIRE_RL_readEdge2 ||
	     WILL_FIRE_RL_readNode3 ;
  assign respQ$DEQ = EN_resp_get ;
  assign respQ$CLR = 1'b0 ;

  // remaining internal signals
  assign vaddrBase__h1738 = nodePtr + { 11'd0, casQ$D_OUT[103:72], 5'd0 } ;
  assign vaddr__h1739 = vaddrBase__h1738 + 48'd8 ;
  assign vaddr__h2349 = edgePtr + { 13'd0, readEdgeQ$D_OUT[39:8], 3'd0 } ;
  assign vaddr__h3055 = nodePtr + { 11'd0, readNodeQ$D_OUT[39:8], 5'd0 } ;
  assign vaddr__h3299 = x__h3329 + 48'd8 ;
  assign x__h3329 = nodePtr + y__h3332 ;
  assign y__h3332 = { 11'd0, readNodeQ2$D_OUT[39:8], 5'd0 } ;
  always@(memReqQ$D_OUT)
  begin
    case (memReqQ$D_OUT[121:119])
      3'd0, 3'd1, 3'd2, 3'd3:
	  CASE_memReqQD_OUT_BITS_121_TO_119_0_memReqQD_ETC__q1 =
	      memReqQ$D_OUT[121:119];
      default: CASE_memReqQD_OUT_BITS_121_TO_119_0_memReqQD_ETC__q1 = 3'd4;
    endcase
  end
  always@(respQ$D_OUT)
  begin
    case (respQ$D_OUT[137:136])
      2'd0, 2'd1:
	  CASE_respQD_OUT_BITS_137_TO_136_0_respQD_OUT_ETC__q2 =
	      respQ$D_OUT[137:136];
      default: CASE_respQD_OUT_BITS_137_TO_136_0_respQD_OUT_ETC__q2 = 2'd2;
    endcase
  end
  always@(memRespQ$D_OUT or
	  memRespQs_0$FULL_N or
	  memRespQs_1$FULL_N or memRespQs_2$FULL_N or memRespQs_3$FULL_N)
  begin
    case (memRespQ$D_OUT[68:64])
      5'd0:
	  CASE_memRespQ_first_BITS_68_TO_64_0_memRespQs__ETC___d8 =
	      memRespQs_0$FULL_N;
      5'd1:
	  CASE_memRespQ_first_BITS_68_TO_64_0_memRespQs__ETC___d8 =
	      memRespQs_1$FULL_N;
      5'd2:
	  CASE_memRespQ_first_BITS_68_TO_64_0_memRespQs__ETC___d8 =
	      memRespQs_2$FULL_N;
      5'd3:
	  CASE_memRespQ_first_BITS_68_TO_64_0_memRespQs__ETC___d8 =
	      memRespQs_3$FULL_N;
      default: CASE_memRespQ_first_BITS_68_TO_64_0_memRespQs__ETC___d8 = 1'd1;
    endcase
  end

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (RST_N == `BSV_RESET_VALUE)
      begin
        started <= `BSV_ASSIGNMENT_DELAY 1'd0;
      end
    else
      begin
        if (started$EN) started <= `BSV_ASSIGNMENT_DELAY started$D_IN;
      end
    if (edgePtr$EN) edgePtr <= `BSV_ASSIGNMENT_DELAY edgePtr$D_IN;
    if (fpgaId$EN) fpgaId <= `BSV_ASSIGNMENT_DELAY fpgaId$D_IN;
    if (laneId$EN) laneId <= `BSV_ASSIGNMENT_DELAY laneId$D_IN;
    if (nodePtr$EN) nodePtr <= `BSV_ASSIGNMENT_DELAY nodePtr$D_IN;
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    edgePtr = 48'hAAAAAAAAAAAA;
    fpgaId = 2'h2;
    laneId = 4'hA;
    nodePtr = 48'hAAAAAAAAAAAA;
    started = 1'h0;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on

  // handling of system tasks

  // synopsys translate_off
  always@(negedge CLK)
  begin
    #0;
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_init)
	begin
	  v__h4360 = $stime;
	  #0;
	end
    v__h4354 = v__h4360 / 32'd10;
    if (RST_N != `BSV_RESET_VALUE)
      if (EN_init)
	$display("%0d: mkGraphEngine[%0d][%0d]: init nodePtr = %0x, edgePtr = %0x",
		 v__h4354,
		 init_fpgaId,
		 init_laneId,
		 init_nodePtr,
		 init_edgePtr);
  end
  // synopsys translate_on
endmodule  // mkGraphLanePipe

