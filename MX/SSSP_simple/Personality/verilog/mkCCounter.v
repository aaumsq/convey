//
// Generated by Bluespec Compiler, version 2014.07.A (build 34078, 2014-07-30)
//
// On Thu Mar  8 22:01:59 CST 2018
//
//
// Ports:
// Name                         I/O  size props
// RDY_init                       O     1 const
// RDY_inc                        O     1 const
// RDY_dec                        O     1 const
// RDY_dec2                       O     1 const
// getVal                         O    10 reg
// RDY_getVal                     O     1 const
// notZero                        O     1
// RDY_notZero                    O     1 const
// notMax                         O     1
// RDY_notMax                     O     1 const
// CLK                            I     1 clock
// RST_N                          I     1 unused
// init_val                       I    10 reg
// EN_init                        I     1
// EN_inc                         I     1
// EN_dec                         I     1
// EN_dec2                        I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkCCounter(CLK,
		  RST_N,

		  init_val,
		  EN_init,
		  RDY_init,

		  EN_inc,
		  RDY_inc,

		  EN_dec,
		  RDY_dec,

		  EN_dec2,
		  RDY_dec2,

		  getVal,
		  RDY_getVal,

		  notZero,
		  RDY_notZero,

		  notMax,
		  RDY_notMax);
  input  CLK;
  input  RST_N;

  // action method init
  input  [9 : 0] init_val;
  input  EN_init;
  output RDY_init;

  // action method inc
  input  EN_inc;
  output RDY_inc;

  // action method dec
  input  EN_dec;
  output RDY_dec;

  // action method dec2
  input  EN_dec2;
  output RDY_dec2;

  // value method getVal
  output [9 : 0] getVal;
  output RDY_getVal;

  // value method notZero
  output notZero;
  output RDY_notZero;

  // value method notMax
  output notMax;
  output RDY_notMax;

  // signals for module outputs
  wire [9 : 0] getVal;
  wire RDY_dec,
       RDY_dec2,
       RDY_getVal,
       RDY_inc,
       RDY_init,
       RDY_notMax,
       RDY_notZero,
       notMax,
       notZero;

  // register maxVal
  reg [9 : 0] maxVal;
  wire [9 : 0] maxVal$D_IN;
  wire maxVal$EN;

  // register val
  reg [9 : 0] val;
  wire [9 : 0] val$D_IN;
  wire val$EN;

  // inputs to muxes for submodule ports
  wire [9 : 0] MUX_val$write_1__VAL_2;

  // remaining internal signals
  wire [9 : 0] IF_increment_whas_AND_IF_decrement_whas_THEN_1_ETC___d41,
	       x__h598,
	       x__h650,
	       x__h668;
  wire [1 : 0] IF_decrement_whas_THEN_1_ELSE_0_PLUS_IF_decrem_ETC___d6;
  wire increment_whas_AND_IF_decrement_whas_THEN_1_EL_ETC___d35;

  // action method init
  assign RDY_init = 1'd1 ;

  // action method inc
  assign RDY_inc = 1'd1 ;

  // action method dec
  assign RDY_dec = 1'd1 ;

  // action method dec2
  assign RDY_dec2 = 1'd1 ;

  // value method getVal
  assign getVal = val ;
  assign RDY_getVal = 1'd1 ;

  // value method notZero
  assign notZero = val != 10'd0 ;
  assign RDY_notZero = 1'd1 ;

  // value method notMax
  assign notMax = val != maxVal ;
  assign RDY_notMax = 1'd1 ;

  // inputs to muxes for submodule ports
  assign MUX_val$write_1__VAL_2 =
	     (EN_inc &&
	      IF_decrement_whas_THEN_1_ELSE_0_PLUS_IF_decrem_ETC___d6 ==
	      2'd0) ?
	       x__h598 :
	       IF_increment_whas_AND_IF_decrement_whas_THEN_1_ETC___d41 ;

  // register maxVal
  assign maxVal$D_IN = init_val ;
  assign maxVal$EN = EN_init ;

  // register val
  assign val$D_IN = EN_init ? 10'd0 : MUX_val$write_1__VAL_2 ;
  assign val$EN =
	     increment_whas_AND_IF_decrement_whas_THEN_1_EL_ETC___d35 ||
	     EN_init ;

  // remaining internal signals
  assign IF_decrement_whas_THEN_1_ELSE_0_PLUS_IF_decrem_ETC___d6 =
	     (EN_dec ? 2'd1 : 2'd0) + (EN_dec2 ? 2'd1 : 2'd0) ;
  assign IF_increment_whas_AND_IF_decrement_whas_THEN_1_ETC___d41 =
	     (EN_inc &&
	      IF_decrement_whas_THEN_1_ELSE_0_PLUS_IF_decrem_ETC___d6 ==
	      2'd2 ||
	      !EN_inc &&
	      IF_decrement_whas_THEN_1_ELSE_0_PLUS_IF_decrem_ETC___d6 ==
	      2'd1) ?
	       x__h650 :
	       x__h668 ;
  assign increment_whas_AND_IF_decrement_whas_THEN_1_EL_ETC___d35 =
	     EN_inc &&
	     IF_decrement_whas_THEN_1_ELSE_0_PLUS_IF_decrem_ETC___d6 ==
	     2'd0 &&
	     val < maxVal ||
	     (!EN_inc ||
	      IF_decrement_whas_THEN_1_ELSE_0_PLUS_IF_decrem_ETC___d6 !=
	      2'd0) &&
	     (!EN_inc ||
	      IF_decrement_whas_THEN_1_ELSE_0_PLUS_IF_decrem_ETC___d6 !=
	      2'd1) &&
	     (EN_inc &&
	      IF_decrement_whas_THEN_1_ELSE_0_PLUS_IF_decrem_ETC___d6 ==
	      2'd2 &&
	      val != 10'd0 ||
	      !EN_inc &&
	      (IF_decrement_whas_THEN_1_ELSE_0_PLUS_IF_decrem_ETC___d6 ==
	       2'd1 ||
	       IF_decrement_whas_THEN_1_ELSE_0_PLUS_IF_decrem_ETC___d6 ==
	       2'd2) &&
	      val != 10'd0) ;
  assign x__h598 = val + 10'd1 ;
  assign x__h650 = val - 10'd1 ;
  assign x__h668 = val - 10'd2 ;

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (maxVal$EN) maxVal <= `BSV_ASSIGNMENT_DELAY maxVal$D_IN;
    if (val$EN) val <= `BSV_ASSIGNMENT_DELAY val$D_IN;
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    maxVal = 10'h2AA;
    val = 10'h2AA;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkCCounter

